<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#050505">
    <title>Neon Lights Out</title>
    <style>
        :root {
            --bg-color: #050505;
            --panel-off: #121212; /* より黒に近づけました */
            --panel-border: #333;
            --neon-main: #0ff;
            --neon-glow: 0 0 10px var(--neon-main), 0 0 20px var(--neon-main);
        }

        * {
            box-sizing: border-box;
            touch-action: manipulation;
            user-select: none;
            -webkit-user-select: none; /* Safari用 */
            -webkit-tap-highlight-color: transparent; /* 重要: タップ時の灰色ハイライトを消す */
            outline: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
        }

        /* Main Game Container */
        #game-wrapper {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }

        #game-container {
            /* グリッドの設定はJSで行うが、アスペクト比を維持して最大化する */
            width: 100%;
            height: 100%;
            max-width: 100%;
            max-height: 100%;
            /* アスペクト比はJSでcols/rowsに基づいて設定するが、初期値として縦長を想定 */
            aspect-ratio: 5 / 8; 
            
            display: grid;
            gap: 6px; /* 隙間を少し詰めて密度を上げる */
            position: relative;
        }

        /* アスペクト比維持のためのフォールバック（縦長画面で横幅いっぱい、横長画面で高さいっぱい） */
        @media (min-aspect-ratio: 5/8) {
            #game-container {
                width: auto;
                height: 100%;
            }
        }
        @media (max-aspect-ratio: 5/8) {
            #game-container {
                width: 100%;
                height: auto;
            }
        }

        /* The Panel */
        .panel {
            background-color: var(--panel-off);
            border: 1px solid var(--panel-border);
            border-radius: 6px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s, box-shadow 0.2s, border-color 0.2s;
            /* box-shadow: inset 0 0 5px rgba(0,0,0,0.8); */ /* パフォーマンスと見た目の簡素化 */
        }
        
        /* 念押しでactive時のスタイルを明示的に指定（デフォルトの上書き） */
        .panel:active {
            background-color: var(--panel-off); 
        }

        /* Lit State */
        .panel.is-lit {
            background-color: rgba(255, 255, 255, 0.1);
            border-color: var(--neon-main);
            box-shadow: var(--neon-glow), inset 0 0 10px var(--neon-main);
            z-index: 1;
        }
        
        /* Lit時のActiveも色が消えないようにする */
        .panel.is-lit:active {
            background-color: rgba(255, 255, 255, 0.15); /* 押した時にほんの少し明るくするフィードバック */
        }

        /* Tap Effect (Flash) - 波紋のような白い光 */
        .panel::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-out;
            border-radius: 4px;
        }

        .panel.flash::after {
            opacity: 0.5;
            transition: none;
        }

        /* Win Animation Styles */
        .panel.win-anim {
            transition: background-color 0.1s, box-shadow 0.1s;
        }
        
        #blocker {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: transparent;
            z-index: 100;
            display: none;
        }

    </style>
</head>
<body>

    <div id="game-wrapper">
        <div id="game-container"></div>
    </div>
    <div id="blocker"></div>

    <script>
        /**
         * Game Configuration
         */
        const CONFIG = {
            cols: 5, // 基本: 横5
            rows: 8, // 基本: 縦8 (スマホ最適化)
            minShuffle: 15, 
            maxShuffle: 35,
            colors: ['#0ff', '#f0f', '#0f0', '#ff0', '#f06', '#80f', '#08f']
        };

        const container = document.getElementById('game-container');
        const blocker = document.getElementById('blocker');
        
        let grid = []; 
        let panels = []; 
        let isAnimating = false;

        /**
         * Initialize Game
         */
        function initGame() {
            container.innerHTML = '';
            panels = [];
            grid = Array(CONFIG.rows).fill().map(() => Array(CONFIG.cols).fill(false));
            isAnimating = false;
            blocker.style.display = 'none';

            // Random Neon Theme
            const randomColor = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
            document.documentElement.style.setProperty('--neon-main', randomColor);

            // Grid Setup
            container.style.gridTemplateColumns = `repeat(${CONFIG.cols}, 1fr)`;
            container.style.gridTemplateRows = `repeat(${CONFIG.rows}, 1fr)`;
            
            // アスペクト比を動的にCSSに適用（CSSメディアクエリの補助）
            container.style.aspectRatio = `${CONFIG.cols} / ${CONFIG.rows}`;

            // 1. Generate Layout with weighted random shapes
            generateLayout();

            // 2. Calculate Neighbors
            calculateNeighbors();

            // 3. Shuffle
            shuffleBoard();
        }

        /**
         * Generate Random Layout
         * レアリティに基づいて形状を選択
         */
        function generateLayout() {
            // 形状定義: [width, height]
            const SHAPES = {
                COMMON: [[1,1]], // 1x1 (穴埋め用)
                UNCOMMON: [[1,2], [2,1], [2,2]], 
                RARE: [[1,3], [3,1], [2,3], [3,2]], 
                EPIC: [[1,4], [4,1], [1,5], [1,6], [2,4]], // かなり長い
                LEGENDARY: [[4,4], [1,8], [2,6]] // 激レア: 4x4, 縦全通しなど
            };

            // 確率設定 (合計100になるように調整しなくても重みとして機能する)
            // 大きいブロックから先に配置を試みる戦略をとる
            
            // まずレジェンダリーな巨大ブロックの配置を試みる (低確率で1回だけトライ)
            if (Math.random() < 0.2) { // 20%の確率で巨大ブロック生成モード
                tryPlaceRandomShape(SHAPES.LEGENDARY);
            }

            // 次にエピック・レアなブロックをいくつか配置試行
            const bigBlockAttempts = Math.floor(Math.random() * 3) + 1;
            for(let i=0; i<bigBlockAttempts; i++) {
                if (Math.random() < 0.5) tryPlaceRandomShape(SHAPES.EPIC);
                if (Math.random() < 0.7) tryPlaceRandomShape(SHAPES.RARE);
            }

            // 残りを埋めるループ
            for (let y = 0; y < CONFIG.rows; y++) {
                for (let x = 0; x < CONFIG.cols; x++) {
                    if (grid[y][x]) continue;

                    // この座標が空いている場合、ここを起点にブロックを置く
                    // 残りのスペースに合わせて、UncommonかCommonを選択
                    let placed = false;
                    
                    // 30%ぐらいでUncommon以上を試す
                    if (Math.random() < 0.3) {
                        placed = tryPlaceShapeAt(x, y, SHAPES.UNCOMMON);
                    }

                    // ダメならCommon (1x1)
                    if (!placed) {
                        placePanel(x, y, 1, 1);
                    }
                }
            }
        }

        // 指定された形状リストからランダムに1つ選んで、ランダムな場所に配置を試みる
        function tryPlaceRandomShape(shapeList) {
            const [w, h] = shapeList[Math.floor(Math.random() * shapeList.length)];
            // ランダムな位置を試行（最大10回トライ）
            for(let i=0; i<10; i++) {
                const tx = Math.floor(Math.random() * (CONFIG.cols - w + 1));
                const ty = Math.floor(Math.random() * (CONFIG.rows - h + 1));
                if (canFit(tx, ty, w, h)) {
                    placePanel(tx, ty, w, h);
                    return true;
                }
            }
            return false;
        }

        // 特定の座標(x,y)を起点に、形状リストの中から置けるものを探す
        function tryPlaceShapeAt(x, y, shapeList) {
            // リストをシャッフル
            const shuffled = [...shapeList].sort(() => Math.random() - 0.5);
            for (let [w, h] of shuffled) {
                if (canFit(x, y, w, h)) {
                    placePanel(x, y, w, h);
                    return true;
                }
            }
            return false;
        }

        function canFit(x, y, w, h) {
            if (x + w > CONFIG.cols || y + h > CONFIG.rows) return false;
            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    if (grid[y + dy][x + dx]) return false;
                }
            }
            return true;
        }

        function placePanel(x, y, w, h) {
            // Update logic grid
            for (let dy = 0; dy < h; dy++) {
                for (let dx = 0; dx < w; dx++) {
                    grid[y + dy][x + dx] = true;
                }
            }

            const el = document.createElement('div');
            el.className = 'panel';
            // CSS Gridの配置
            el.style.gridColumnStart = x + 1;
            el.style.gridColumnEnd = x + 1 + w;
            el.style.gridRowStart = y + 1;
            el.style.gridRowEnd = y + 1 + h;
            
            const panelObj = {
                id: panels.length,
                el: el,
                x: x, y: y, w: w, h: h,
                lit: false,
                neighbors: []
            };

            // Touch Handling (修正: touchstart/clickの重複防止と高速化)
            // 'pointerdown' はスマホ・PC両対応で便利
            el.addEventListener('pointerdown', (e) => {
                if (isAnimating) return;
                e.preventDefault(); 
                handleTap(panelObj);
            });

            container.appendChild(el);
            panels.push(panelObj);
        }

        function calculateNeighbors() {
            for (let i = 0; i < panels.length; i++) {
                for (let j = i + 1; j < panels.length; j++) {
                    if (isAdjacent(panels[i], panels[j])) {
                        panels[i].neighbors.push(panels[j]);
                        panels[j].neighbors.push(panels[i]);
                    }
                }
            }
        }

        function isAdjacent(p1, p2) {
            const touchX = (p1.x < p2.x + p2.w) && (p1.x + p1.w > p2.x);
            const touchY = (p1.y < p2.y + p2.h) && (p1.y + p1.h > p2.y);
            const adjacentX = (p1.x === p2.x + p2.w) || (p1.x + p1.w === p2.x);
            const adjacentY = (p1.y === p2.y + p2.h) || (p1.y + p1.h === p2.y);
            return (touchX && adjacentY) || (touchY && adjacentX);
        }

        function toggle(panel, triggerVisuals = true) {
            panel.lit = !panel.lit;
            if (panel.lit) {
                panel.el.classList.add('is-lit');
            } else {
                panel.el.classList.remove('is-lit');
            }

            if (triggerVisuals) {
                panel.el.classList.remove('flash');
                void panel.el.offsetWidth; 
                panel.el.classList.add('flash');
            }
        }

        function handleTap(targetPanel) {
            toggle(targetPanel);
            targetPanel.neighbors.forEach(n => toggle(n));
            checkWin();
        }

        function shuffleBoard() {
            const clicks = CONFIG.minShuffle + Math.floor(Math.random() * (CONFIG.maxShuffle - CONFIG.minShuffle));
            
            for (let i = 0; i < clicks; i++) {
                const r = Math.floor(Math.random() * panels.length);
                const p = panels[r];
                p.lit = !p.lit;
                p.neighbors.forEach(n => n.lit = !n.lit);
            }

            // Sync DOM
            let anyLit = false;
            panels.forEach(p => {
                if (p.lit) {
                    p.el.classList.add('is-lit');
                    anyLit = true;
                } else {
                    p.el.classList.remove('is-lit');
                }
            });

            // 万が一全部消えてたら、もう一回適当なところを押す
            if (!anyLit) {
                const p = panels[Math.floor(Math.random() * panels.length)];
                toggle(p, false); // false = no flash
                p.neighbors.forEach(n => toggle(n, false));
            }
        }

        function checkWin() {
            const allOff = panels.every(p => !p.lit);
            if (allOff) {
                playWinSequence();
            }
        }

        function playWinSequence() {
            isAnimating = true;
            blocker.style.display = 'block';

            setTimeout(() => {
                const sortedPanels = [...panels].sort((a, b) => (a.x + a.y) - (b.x + b.y));
                
                let delay = 0;
                sortedPanels.forEach((p) => {
                    setTimeout(() => {
                        p.el.classList.add('is-lit');
                        p.el.classList.add('win-anim');
                    }, delay);
                    
                    setTimeout(() => {
                        p.el.classList.remove('is-lit');
                        setTimeout(() => p.el.classList.remove('win-anim'), 200);
                    }, delay + 300);

                    delay += 40;
                });

                setTimeout(() => {
                    initGame();
                }, delay + 1200);

            }, 200);
        }

        window.onload = initGame;

    </script>
</body>
</html>